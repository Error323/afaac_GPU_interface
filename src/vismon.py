#!/usr/bin/python
# Script to generate uncalibrated images from a live (RT) GPU visibility stream.
# pep/29Oct14

import sys;
import socket;
import optparse;
try:
	import numpy;
	numpyFound = 1;
except ImportError:
	numpyFound = 0;

import math;
try:
	import scipy.io as sio;
	scipyFound = 1;
except ImportError:
	scipyFound = 0;

import os;
import struct;
try:
	import matplotlib.pylab as plt;
	matplotFound = 1;
except ImportError:
	matplotFound = 0;

class subbandHandler:
	'Class representing data from a single subband of visibilities, as generated by the GPU correlator'
	
	# Public variables, shared between all class instances.
	Sb2Port = {'sb0':5556, 'sb1':5556};
	Nsec2Rd = 10000; # -1 indicates read infinitely
	Nelem  = 288;       
	Nbline= Nelem*(Nelem+1)/2; 
	Nchan = 63;
	Npol = 4;
	NRec2Buf = 2; # Number of records in local buffer.
	Hdrsize = 512;
	Recsize = Hdrsize + Nbline*Nchan*Npol*2*4; # 4 is for sizeof (float), 2 is for complex float.

	# Private variables
	# Create an array for every timeslice from all subbands
	_tobs = numpy.zeros (NRec2Buf, 'd'); # Time of obs, as double
	_vis = numpy.zeros ([Nbline, Nchan, Npol, 2], 'f');
	_vis_int = numpy.zeros ([Nbline, Npol, 2], 'f');
	_acm = numpy.zeros ([Npol, Nelem*Nelem], dtype=complex);
	_sel = numpy.nonzero(numpy.triu(numpy.ones([Nelem,Nelem])).flatten(1) == 1);
	_streamtype = 'file'; # Default
	_meta = numpy.zeros ([1, 128], dtype=numpy.int); # 512Byte file header.

	""" desc. is a string descriptor of the source of data
		file:filename  = If gpu output is dumped to disk
		tcp:port       = if gpu output is streamed over network
	"""
	def __init__ (self, desc, sbnum):
		self._streamtype = desc.split(':')[0];
		self._sbnum = sbnum;

		if self._streamtype == 'file':
			print '--> Operating on file ', desc.split(':')[1];
			try:
				self._fid = open (desc.split(':')[1], "rb");	
			except IOError:
				print 'File ', desc.split(':')[1], ' does not exist. Quitting.';
				
		elif self._streamtype == 'tcp':
			print '--> Operating on TCP socket.';
			self._fid = socket.socket (socket.AF_INET, socket.SOCK_STREAM);
			self._fid.bind( ('', self.Sb2Port[sbnum]) );
			print '--> Binding on port ', self.Sb2Port[sbnum], ' for subband ', sbnum;
			self._fid.listen(1); # Blocking wait
			print '--> Found remote sender';
			self._clientconn,self._clientaddr = self._fid.accept ();
			print '--> Conn', self._clientconn, ' Addr: ', self._clientaddr; 
		else:
			print '### Unknown descriptor type ', self._streamtype, ' Quitting!';
			sys.exit();


	def __del__(self):
		print '<-- Clearing memory';
		if self._streamtype == 'file':
			self._fid.close();
		elif self._streamtype == 'tcp':
			self._clientconn.close();


	def readRec (self): # Can include number of records to read here TODO
		if self._streamtype == 'file':
			rec = self._fid.read (self.Recsize);
			if not rec: 
				print 'EOF reached. Last few records may be discarded.\n';
		 		Doneread = 1;

		elif self._streamtype == 'tcp':	
			bytes_recv = 0;
			self._chunks = [];
			ind = 0;
			while bytes_recv < self.Recsize:
				chunk = self._clientconn.recv (min ((self.Recsize - bytes_recv), 20480));
				# if chunk == b'':
				# 	raise RuntimeError ("Socket connection broken");
				self._chunks.append(chunk);
				bytes_recv = bytes_recv + len (chunk);
				ind = ind + 1;

			rec = ''.join(self._chunks);
		else:
			print 'Unknown streamtype: ', self_streamtype;
			
			# TOTO RAise an exception here.
		
		(magic, pad0, self._tobs, endTime) = struct.unpack ("<IIdd", rec[0:24]);
		print 'Start: %.2f, End: %.2f' % (self._tobs, endTime);
		self._fobs = 60000000; # TODO: Meta information needed here!
		self._vis = numpy.reshape (numpy.asarray (struct.unpack ("ff"*self.Nbline*self.Nchan*self.Npol, rec[512:])),[self.Nbline, self.Nchan, self.Npol, 2]);
		self._vis_int = numpy.mean (self._vis, axis=1);
		for ind in range (0, self.Npol):
			# self._acm [ind][self._sel] = self._vis_int[:][ind][0] + 1j*self._vis_int[:][ind][1];
			self._acm [ind,self._sel] = self._vis_int[:,ind,0] + 1j*self._vis_int[:,ind,1];

		return numpy.reshape (self._acm, [self.Npol, self.Nelem, self.Nelem]), self._tobs, self._fobs;
	

class imager:
	'Class representing data from a single subband of visibilities, as generated by the GPU correlator'
	# Public variables, shared between all class instances;
	C = 2.9979245e8; # m/s

	# Private variables
	_npix = 500; # In both X and Y
	_mode = 'dft';


	def __init__ (self, npix, mode, fobs):
		self._npix = npix;
		self._skymap = numpy.asmatrix(numpy.zeros([self._npix, self._npix], 'f'));
		self._l = numpy.asmatrix (numpy.linspace(-1, 1, self._npix));
		self._tobs = -1; self._fobs = -1;

		# Load antenna positions
		mat_contents = sio.loadmat ('poslocal_outer.mat');
		self._poslocal = numpy.asmatrix (mat_contents['poslocal']);

		if mode == 'fft':
# Generate uv coordinates in local horizon coord. system, needed for imaging
			_uloc = numpy.meshgrid (self._poslocal[:,0]) - numpy.meshgrid (self._poslocal[:,0].transpose());
			_vloc = numpy.meshgrid (self._poslocal[:,1]) - numpy.meshgrid (self._poslocal[:,1].transpose());
			_duv = 2.5;				# Default, reassigned from freq. of obs. to
									# image just the full Fov (-1<l<1)
			_Nuv = 1000;			# size of gridded visibility matrix
			_uvpad = 1024;			# specifies if any padding needs to be added
			_dl = (self.C/(fobx * _uvpad * _duv)); # dimensionless, in dir. cos. units
			_lmax = dl * gparm.uvpad / 2;
			_gridvis = numpy.zeros ([_Nuv, _Nuv]);

		elif mode == 'dft':
			# Create imaging weights for DFT imaging
		  	wavelength = self.C / fobs;
			k = 2 * math.pi / wavelength;
			self._wx = numpy.exp(-1j * k * self._poslocal[:,0] * self._l);
			self._wy = numpy.exp(-1j * k * self._poslocal[:,1] * self._l);

	""" DFT based imager.
		Arge: acm  = 4xNelemxNelem complex matrix
			  tobs = time of observation in unix time
			  pols = tuple of bools to control imaging of polarizations
	"""
	def createImageDFT (self, acm, tobs, fobs, pols):
		self._tobs = tobs;
		self._fobs = fobs;
		acm[0][:][:] = acm[0][:][:]+acm[0][:][:].conj().transpose();
		for lidx in range (0, self._npix):
			for midx in range (0, self._npix):
				weight = numpy.multiply(self._wx[:, lidx],self._wy[:, midx]);
				# print 'weight:', numpy.shape(weight), ' acm:', numpy.shape(acm);
				self._skymap[lidx, midx] = (weight.conj().transpose() * acm[0][:][:] * weight).real;

		return self._skymap;


	def gridVis (self, acm):
			
		for idx in range (0, len(self._uloc.flatten(1))): 
		    ampl = abs(acm[idx]);
		    phasor = acc[idx] / ampl;
		    uidx = self._uloc[idx] / self._duv + self._Nuv/2;
		    uidxl = math.floor(uidx);
		    uidxh = math.ceil(uidx);
		    dul = abs(uidx - uidxl);
		    duh = abs(uidx - uidxh);
		    sul = duh * ampl;
		    suh = dul * ampl;
		    
		    vidx = self._vloc[idx] / self._duv + self._Nuv / 2;
		    vidxl = math.floor(vidx);
		    vidxh = math.ceil(vidx);
		    dvl = abs(vidx - vidxl);
		    dvh = abs(vidx - vidxh);
		    sull = dvh * sul;
		    sulh = dvl * sul;
		    suhl = dvh * suh;
		    suhh = dvl * suh;
		    
		    self._gridvis[uidxl, vidxl] = self._gridvis[uidxl, vidxl] + sull * phasor;
		    self._gridvis[uidxl, vidxh] = self._gridvis[uidxl, vidxh] + sulh * phasor;
		    self._gridvis[uidxh, vidxl] = self._gridvis[uidxh, vidxl] + suhl * phasor;
		    self._gridvis[uidxh, vidxh] = self._gridvis[uidxh, vidxh] + suhh * phasor;
		    
#		# zero padding to desired (u,v)-size
#		N = size(vis, 1);
#		N1 = floor((uvsize - N) / 2);
#		N2 = ceil((uvsize + 1 - N) / 2) - 1;
#		vispad = [zeros(N1, uvsize); ...
#		          zeros(N, N1), vis, zeros(N, N2); ...
#		          zeros(N2, uvsize)];
#		vispad(~isfinite(vispad)) = 0;
#
#
#	def createImageFFT (self, acm_grid, tobs, pols):
#		# compute image
#		skymap = fftshift(fft2(vispad));

	def writeFileMeta(self, fid):
		array(self._meta).tofile(fid,sep="");		

	def writeImgToFile (self, fid):
		numpy.array(float(self._tobs)).tofile(fid,sep="");# Written as float64	
		numpy.array(float(self._fobs)).tofile(fid,sep="");# Written as float64
		skymap1 = numpy.array(self._skymap);   # skymap is a matrix type otherwise
		skymap1.tofile(fid,sep="");# Written as float32

	def readImgFromFile (self, fid):
		t = numpy.fromfile (fid, dtype='float64',count=2);		
		img = numpy.fromfile (fid, dtype='float32',count=self._npix*self._npix);
		return t[0], t[1], img;
		

if __name__ == '__main__':
	if numpyFound == 0 | scipyFound == 0:
		print '### Numpy and/or scipy not found; unable to proceed.';
		sys.exit(-1);

	sb = subbandHandler (sys.argv[2], 'sb0');
	im = imager (500, 'dft', 60000000);
	irec = 0;


	# First record reading
	acm, tobs, fobs = sb.readRec();
	skymap = im.createImageDFT (acm, tobs, fobs, [1, 0, 0,0]);

	# Generate output file name based on first timeinstant
	fname = '%s/%.0f_images.bin' % (sys.argv[1],tobs);
	print '--> Writing to directory ', sys.argv[1];
	fid = open (fname, "wb");

	if matplotFound == 1:
		imgplt = plt.imshow (skymap);
		plt.colorbar();
	else:
		print '### Matplotlib not found. Writing images to disk.';

	while irec < subbandHandler.Nsec2Rd:
		acm, tobs, fobs = sb.readRec();
		# skymap = im.createImageDFT (acm, tobs, [1, 0, 0, 0]);

		if matplotFound == 1:
			imgplt.set_data (skymap);
			plt.draw();
			plt.title ('XX - %f' % tobs);
			plt.savefig ('%s/%.0f_XX.png' % (sys.argv[1],tobs));
		# else:
		im.writeImgToFile (fid);
		irec = irec + 1;
