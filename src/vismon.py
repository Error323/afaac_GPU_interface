#!/usr/bin/python
# Script to generate uncalibrated images from a live (RT) GPU visibility stream.
# pep/29Oct14

import sys;
import socket;
import optparse;
try:
	import numpy;
	numpyFound = 1;
except ImportError:
	numpyFound = 0;

import math;
try:
	import scipy.io as sio;
	scipyFound = 1;
except ImportError:
	scipyFound = 0;

import os;
import struct;
try:
	import matplotlib.pylab as plt;
	import matplotlib.animation as animation;
	matplotFound = 1;
except ImportError:
	matplotFound = 0;

class subbandHandler:
	'Class representing data from a single subband of visibilities, as generated by the GPU correlator'
	
	# Public variables, shared between all class instances.
	Sb2Port = {'sb0':5556, 'sb1':5556};
	Nsec2Rd = 10000; # -1 indicates read infinitely
	Nelem  = 288;       
	Nbline= Nelem*(Nelem+1)/2; 
	Nchan = 63;
	Npol = 4;
	NRec2Buf = 2; # Number of records in local buffer.
	Hdrsize = 512;
	Recsize = Hdrsize + Nbline*Nchan*Npol*2*4; # 4 is for sizeof (float), 2 is for complex float.

	# Private variables
	# Create an array for every timeslice from all subbands
	_tobs = numpy.zeros (NRec2Buf, 'd'); # Time of obs, as double
	_vis = numpy.zeros ([Nbline, Nchan, Npol, 2], 'f');
	_vis_int = numpy.zeros ([Nbline, Npol, 2], 'f');
	_acm = numpy.zeros ([Npol, Nelem*Nelem], dtype=complex);
	_acm_resh = numpy.zeros ([Npol, Nelem, Nelem], dtype=complex);
	_sel = numpy.nonzero(numpy.triu(numpy.ones([Nelem,Nelem])).flatten(1) == 1);
	_streamtype = 'file'; # Default
	_meta = numpy.zeros ([1, 128], dtype=numpy.int); # 512Byte file header.

	""" desc. is a string descriptor of the source of data
		file:filename  = If gpu output is dumped to disk
		tcp:port       = if gpu output is streamed over network
	"""
	def __init__ (self, desc, sbnum):
		self._streamtype = desc.split(':')[0];
		self._sbnum = sbnum;

		if self._streamtype == 'file':
			print '--> Operating on file ', desc.split(':')[1];
			try:
				self._fid = open (desc.split(':')[1], "rb");	
			except IOError:
				print 'File ', desc.split(':')[1], ' does not exist. Quitting.';
				
		elif self._streamtype == 'tcp':
			print '--> Operating on TCP socket.';
			self._fid = socket.socket (socket.AF_INET, socket.SOCK_STREAM);
			self._fid.bind( ('', self.Sb2Port[sbnum]) );
			print '--> Binding on port ', self.Sb2Port[sbnum], ' for subband ', sbnum;
			self._fid.listen(1); # Blocking wait
			print '--> Found remote sender';
			self._clientconn,self._clientaddr = self._fid.accept ();
			print '--> Conn', self._clientconn, ' Addr: ', self._clientaddr; 
		else:
			print '### Unknown descriptor type ', self._streamtype, ' Quitting!';
			sys.exit();


	def __del__(self):
		print '<-- Clearing memory';
		if self._streamtype == 'file':
			self._fid.close();
		elif self._streamtype == 'tcp':
			self._clientconn.close();


	def readRec (self): # Can include number of records to read here TODO
		if self._streamtype == 'file':
			rec = self._fid.read (self.Recsize);
			if not rec: 
				print 'EOF reached. Last few records may be discarded.\n';
		 		Doneread = 1;

		elif self._streamtype == 'tcp':	
			bytes_recv = 0;
			self._chunks = [];
			ind = 0;
			while bytes_recv < self.Recsize:
				chunk = self._clientconn.recv (min ((self.Recsize - bytes_recv), 20480));
				# if chunk == b'':
				# 	raise RuntimeError ("Socket connection broken");
				self._chunks.append(chunk);
				bytes_recv = bytes_recv + len (chunk);
				ind = ind + 1;

			rec = ''.join(self._chunks);
		else:
			print 'Unknown streamtype: ', self_streamtype;
			
			# TOTO RAise an exception here.
		
		(magic, pad0, self._tobs, endTime) = struct.unpack ("<IIdd", rec[0:24]);
		print 'Start: %.2f, End: %.2f' % (self._tobs, endTime);
		self._fobs = 60000000; # TODO: Meta information needed here!
		self._vis = numpy.reshape (numpy.asarray (struct.unpack ("ff"*self.Nbline*self.Nchan*self.Npol, rec[512:])),[self.Nbline, self.Nchan, self.Npol, 2]);

		# Integrating over all channels in a subband;
		self._vis_int = numpy.mean (self._vis, axis=1);

		# NOTE: Required to set acm to zero due to accumulation on _acm_resh,
		# which is a view (referenced object).
		self._acm[:,:]= 0;
		for ind in range (0, self.Npol):
			self._acm [ind,self._sel] = self._vis_int[:,ind,0] + 1j*self._vis_int[:,ind,1];

		# Make ACM hermitian symmetric
		self._acm_resh = numpy.reshape (self._acm, [self.Npol, self.Nelem, self.Nelem]);
		for ind in range (0, self.Npol):
			self._acm_resh [ind,:,:] = self._acm_resh[ind,:,:] + self._acm_resh[ind,:,:].conj().transpose();
	
		return self._acm_resh, self._tobs, self._fobs;

class imager:
	'Class representing data from a single subband of visibilities, as generated by the GPU correlator'
	# Public variables, shared between all class instances;
	C = 2.9979245e8; # m/s

	# Private variables
	_mode = 'dft';
	_npix = 500; # In both X and Y


	def __init__ (self, npix, mode, fobs):
		self._npix = npix;
		self._skymap = numpy.asmatrix(numpy.zeros([self._npix, self._npix], 'f'));
		self._tobs = -1; self._fobs = -1;
		self._mode = mode;
		print '--> Creating Imager in %s mode with npix %d' % (self._mode, self._npix);

		# Load antenna positions
		mat_contents = sio.loadmat ('poslocal_outer.mat');
		self._poslocal = numpy.asmatrix (mat_contents['poslocal']);

		if self._mode == 'fft':
			# Generate uv coordinates in local horizon coord. system, needed for
			# imaging.
			u1, v1 = numpy.meshgrid (numpy.asarray(self._poslocal[:,0]), numpy.asarray(self._poslocal[:,1]));
			v2, u2 = numpy.meshgrid (numpy.asarray(self._poslocal[:,1]), numpy.asarray(self._poslocal[:,0]));
			self._uloc = (u1 - u2).flatten(1);
			self._vloc = (v1 - v2).flatten(1);

			"""
			plt.figure ();
			plt.imshow (_uloc);
			plt.figure ();
			plt.imshow (_vloc);
			plt.show ();
			"""
			self._duv = 2.5;				# Default, reassigned from freq. of obs. to
									# image just the full Fov (-1<l<1)
			self._Nuv = 1000;			# size of gridded visibility matrix
			self._npix= 1024;			# specifies if any padding needs to be added
			self._dl = (self.C/(self._fobs * self._npix* self._duv)); # dimensionless, in dir. cos. units
			self._lmax = self._dl * self._npix/ 2;
			self._gridvis = numpy.zeros ([self._npix, self._npix], dtype=complex);

		elif self._mode == 'dft':
			self._l = numpy.asmatrix (numpy.linspace(-1, 1, self._npix));
			self._m = self._l;

			# Create imaging weights for DFT imaging
		  	wavelength = self.C / fobs;
			k = 2 * math.pi / wavelength;
			self._wx = numpy.exp(-1j * k * self._poslocal[:,0] * self._l);
			self._wy = numpy.exp(-1j * k * self._poslocal[:,1] * self._l);

	def createImage (self, acm, tobs, fobs, pols):
		# First make the acm hermitian symmetric;
		if self._mode.lower() == 'dft':
			self.createImageDFT (acm[0,:,:], tobs, fobs, pols);
		else:
			self.createImageFFT (acm[0,:,:], tobs, fobs, pols);

	""" DFT based imager.
		Arge: acm  = 4xNelemxNelem complex matrix
			  tobs = time of observation in unix time
			  pols = tuple of bools to control imaging of polarizations
	"""
	def createImageDFT (self, acm, tobs, fobs, pols):
		self._tobs = tobs;
		self._fobs = fobs;
		# acm[0][:][:] = acm[0][:][:]+acm[0][:][:].conj().transpose();
		self._skymap[:,:] = 0;
		for lidx in range (0, self._npix):
			for midx in range (0, self._npix):
				weight = numpy.multiply(self._wx[:, lidx],self._wy[:, midx]);
				self._skymap[lidx, midx] = (weight.conj().transpose() * acm[0][:][:] * weight).real;

		return self._skymap;


	def gridVis (self, acm):
	
		# For zero padding to desired (u,v)-size
		N1 = numpy.floor((self._npix - self._Nuv) / 2);
		self._gridvis[:,:] = 0;
			
		for idx in range (0, len(self._uloc)):
			ampl = abs(acm[idx]);
			if ampl == 0:
				phasor = 0;
			else:
				phasor = acm[idx] / ampl;
			uidx = self._uloc[idx] / self._duv + self._Nuv/2;
			uidxl = math.floor(uidx);
			uidxh = math.ceil(uidx);
			dul = abs(uidx - uidxl);
			duh = abs(uidx - uidxh);
			sul = duh * ampl;
			suh = dul * ampl;
			
			vidx = self._vloc[idx] / self._duv + self._Nuv / 2;
			vidxl = math.floor(vidx);
			vidxh = math.ceil(vidx);
			dvl = abs(vidx - vidxl);
			dvh = abs(vidx - vidxh);
			sull = dvh * sul;
			sulh = dvl * sul;
			suhl = dvh * suh;
			suhh = dvl * suh;
			
			self._gridvis[N1+uidxl, vidxl+N1] = self._gridvis[N1+uidxl, vidxl+N1] + sull * phasor;
			self._gridvis[N1+uidxl, vidxh+N1] = self._gridvis[N1+uidxl, vidxh+N1] + sulh * phasor;
			self._gridvis[N1+uidxh, vidxl+N1] = self._gridvis[N1+uidxh, vidxl+N1] + suhl * phasor;
			self._gridvis[N1+uidxh, vidxh+N1] = self._gridvis[N1+uidxh, vidxh+N1] + suhh * phasor;
		    
	def createImageFFT (self, acm, tobs, fobs, pols):
		# Grid visibilities;
		self.gridVis (acm.flatten(1));

		# compute image
		self._skymap = numpy.fft.fftshift(numpy.fft.fft2(self._gridvis));
		return self._skymap;

	""" Function reads a file containing images written by writeImgToFile and 
		generates a GIF out of them.
	"""
	def convertImgToGIF (self, fid):
		return None; # TODO.

	def writeFileMeta(self, fid):
		array(self._meta).tofile(fid,sep="");		

	def writeImgToFile (self, fid):
		numpy.array(float(self._tobs)).tofile(fid,sep="");# Written as float64	
		numpy.array(float(self._fobs)).tofile(fid,sep="");# Written as float64
		skymap1 = numpy.array(self._skymap);   # skymap is a matrix type otherwise
		skymap1.tofile(fid,sep="");# Written as float32

	def readImgFromFile (self, fid):
		t = numpy.fromfile (fid, dtype='float64',count=2);		
		img = numpy.fromfile (fid, dtype='float32',count=self._npix*self._npix);
		return t[0], t[1], img;
		

if __name__ == '__main__':
	if numpyFound == 0 | scipyFound == 0:
		print '### Numpy and/or scipy not found; unable to proceed.';
		sys.exit(-1);
	o = optparse.OptionParser()
	o.set_usage('vismon.py [options]')
	o.set_description(__doc__)

	o.add_option('-i', '--in', dest='fin', 
    	help='Specify the source of visibilities to image');

	o.add_option('-o', '--out', dest='fout',
		help='Specify the prefix of output files.  If it exists, generated images will be added to the map file.  Othewise, the file will be created.');

	o.add_option('-m', '--mode', dest='mode', default='fft', 
		help='Mode of imaging: dft or fft');
	o.add_option('-n', '--npix', type='int', dest='npix', default=512,
		help='Number of pixels in output image');

	opts, args = o.parse_args(sys.argv[1:])

	sb = subbandHandler (opts.fin, 'sb0');
	im = imager (opts.npix, opts.mode, 60000000);
	irec = 0;


	# First record reading
	acm, tobs, fobs = sb.readRec();
	# print 'readRec: Vis abs: ', abs(acm[0,234,123]);
	im.createImage (acm, tobs, fobs, [1, 0, 0, 0]);

	# Generate output file name based on first timeinstant
	print '--> Writing with prefix ', opts.fout;
	fname = '%s/%.0f_XX.img' % (opts.fout, tobs);
	print 'Filename:', fname;
	fid = open (fname, "wb");

	if matplotFound == 1:
		# ax = fig.add_subplot(111);
		imgplt = plt.imshow (abs(im._skymap));
		plt.colorbar();
		# plt.show();
	else:
		print '### Matplotlib not found. Writing images to disk.';

	while irec < subbandHandler.Nsec2Rd:
		acm, tobs, fobs = sb.readRec();
		im.createImage (acm, tobs, fobs, [1, 0, 0, 0]);

		if matplotFound == 1:
			imgplt.set_data (abs(im._skymap));
			plt.title ('XX - %f' % tobs);
			plt.draw();
			plt.savefig ('%s/%.0f_XX.png' % (opts.fout,tobs));
		# else:
		im.writeImgToFile (fid);
		irec = irec + 1;
